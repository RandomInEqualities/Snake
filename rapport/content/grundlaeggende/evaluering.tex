\section{Evaluering}

\subsubsection{Opbygning af banen}
Først overvejede vi at designe banen som et to-dimensionelt array. Et [10][5]-array vil f.eks. give en bane med 10 rækker og 5 kolonner. Hvert element i arrayet bestemmer da, hvad der befinder sig på netop dennes plads. Elementerne i arrayet kan f.eks. være et blankt felt, mad, et led af slangen osv. Dette gør det nemt at introducere nye spilelementer i fremtiden, f.eks. bonus-point, vægge og miner, idet der blot skal tilføjes nye værdityper. Visualisering af spillet foregår ved at definere et billede for hvert spilelement, og få programmet til at tegne objektet på arrayets plads.

Vi valgte dog ikke denne metode, idet det to-dimensionelle array med banens størrelse skal sendes til 'paintComponent'-metoden, hver gang banen skal tegnes. For en bane på f.eks. $100\times 100$ felter betyder det, at der i alt sendes 10.000 elementer til en view-klasse, hver gang banen skal tegnes - dvs. hver gang slangen bevæger sig. Vores anvendte metode sender derimod kun de relevante felter, dvs. madens og slangens position til view-koden. Denne behøver derfor ikke at tage hensyn til de andre felter, som er er tomme og uændret. En anden ulempe er, at det er mere kompliceret at bruge dette array. Hvis man f.eks. vil vide hvor slangen befinder sig, skal man loop igennem hele arrayet.

\subsubsection{Slangens dele}
Da slangen i snake-spillet består af en række felter, som alle har netop et koordinatpar, er en effektiv måde at gemme slangens position på en ArrayList, idet dennes datastruktur er fleksibel i størrelse og passer til formålet. Når slangen vokser i størrelse, bliver dette dog mindre effektivt, idet slangens hoved altid sættes som element 0, hvorved hele listen skal flyttes for at gøre plads. En anden mulighed ville være at bruge en anden datastruktur, f.eks. LinkedList, eller lade hovedet være defineret som elementet i index positions.size()-1 - altså sidst i listen. Et problem ved at bruge LinkedList er dog, at denne datastruktur ikke tillader vilkårlig adgang af værdier, men derimod altid bevæger sig fra første eller sidste element, indtil den når ind til det ønskede element. Dette problem kan løses ved at bruge en iterator, men blev fravalgt, idet det skabte problemer, når listen skulle bruges på tværs af klasserne.

\subsubsection{Score}
Til implementationen af scoren blev to løsninger foreslået. Enten lades scoren være et datafelt i \textit{Game}-klassen, ellers lades den være en klasse for sig selv. Ved at lade scoren være et datafelt, bliver implementationen simplere. At lade scoren være en klasse for sig selv har derimod fordelen, at der kan tilføjes en Observer til \textit{Score}-klassen, som dermed kun opdateres, når scoren ændrer sig. Scorepanelet tegnes ikke i samme klasse som banen, og kan derfor holdes separat, så score-panelet kun gentegnes, når scoren ændrer sig, mens banen med slangen gentegnes hver eneste gang slangen har bevæget sig. Hvis scoren derimod er et datafelt, tegnes scoren hver gang spillet opdateres og altså efter hver tur - også selvom scoren er uændret. Vi implementerede først scoren som en klasse, men ændrede dette senere da, det var for meget at operette en klasse, der kun holdte øje med en enkelt integer.

\subsubsection{Tegning af spillet}
For at visualisere spillet er det nødvendigt at kunne optegne banen, slangen og maden. Dette gøres i klassen \textit{BoardPanel}, som har metoderne 'drawLevel', 'drawSnake' og 'drawFood', som hver især tegner deres tilsvarende element. Metoden 'paintComponent' kalder de førnævnte metoder, således at baggrunden tegnes først, så banen, så maden og til sidst slangen. Alting gentegnes hver gang spillet opdateres, hvorved der "tegnes over" det gamle billede. Det kan her argumenteres for, at baggrunden for eksempel ikke bør gentegnes, når slangen bevæger sig, ligesom store dele af banen forbliver uændret, og derfor ikke behøver gentegning. Alternativt kunne man lave et system, som undersøger hvilke områder der skal gentegnes, og hvilke der er uændret, og derfor ikke skal gentegnes. Dette kan dog i sidste ende betyde, at de kræfter der spares på tegning i stedet blot bruges på at afgøre, hvad der skal tegnes.

\subsubsection{Skalering af banen}
Gives hvert felt en absolut størrelse, ser spillepladen altid pæn ud, og kommer ikke til at afhænge af alle mulige vinduesforhold. Ulempen er bare, at alt efter hvor stor banen er, så kan vinduet blive for stort til computerskærmen, og hvis den er for lille, kan banen ikke forstørres. På denne måde er det en "for simpel" løsning bare at sætte faste værdier ind, for ikke at få en "grim" bane.
Problemet bliver løst i Advanced Snake ved konstant at beregne den optimale feltstørrelse og dermed bevare forholdet mellem feltets længde og højde, mens resterende plads bliver udfyldt af baggrunden.

\subsubsection{Brug af \textit{Game}-klassen}
Efter vi havde delt de fleste funktioner ud i klasserne, besluttede vi os for at samle nogle metoder i \textit{Game}-klassen frem for deres oprindelige klasse, f.eks. \textit{findFoodPosition}-metoden og banens oprettelse. Vi satte ikke 'move'-metoden ind i \textit{Game}-klassen frem for \textit{Snake}-klassen, da den ikke som sådan skal bruge informationer fra andre klasser. Slangen skal bare bevæge sig afhængig af \textit{Control}-klassen. Logisk giver det også mening at slangen bevæger sig som en uafhængig enhed, og at det ikke er \textit{Game} som flytter slangen. Det giver os dog den ekstra afhængighed at \textit{Snake} er nødt til at kende til \textit{Game}-klassen, så den ved hvor at maden ligger og hvor stor banen er.