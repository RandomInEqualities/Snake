\section{Evaluering}
 
\subsubsection{Arbejdsproces}
Formålet med projektet var at starte med at lave en simpel udgave af snake, og derefter tilføje flere funktioner for at lave en mere avanceret version. Dette gør det ideelt at tilføje én funktion ad gangen, frem for at planlægge alle funktioner på en gang, og tilføje dem samtidig. Resultatet bliver et, til at starte med, simpelt men fungerende program, hvorefter yderligere funktioner kan tilføjes. Programmet er altså udviklet iterativt, hvorved der opstår flere fungerende versioner af spillet, men med forskellige funktioner. Dette gør det muligt at tilpasse programmet, hvis der opstår nye idéer eller krav undervejs. 
 
Den iterative tilgang gør det muligt at have en "cyklus" for udviklingen af programmet. Først bestemmes det, der skal tilføjes til programmet. Derefter fordeles opgaverne blandt gruppens medlemmer. Gruppemedlemmet afgør selv, hvordan en funktion skal designes og implementeres, men sikrer at implementationen er kompatibel med alle nuværende funktioner, og ikke vil hindre fremtidige tilføjelser i at blive tilføjet. Eventuelle justeringer til programmet laves for at undgå fejl med nye funktioner, hvorefter "cyklussen" starter forfra ved idéfasen.

\subsubsection{Opbygning af banen}
Vi overvejede at designe banen som et dobbeltarray. F.eks. et array [10][5] vil give en bane med længden 10 og bredden 5. Hvert element i arrayet bestemmer da, hvad der befiner sig på netop denne plads på banen. Elementerne i arrayet kan f.eks. være et blankt felt, et æble, et led af slangen osv. Dette gør det nemt at introducere nye spilelementer i fremtiden, f.eks. bonus-point, vægge og miner, idet der blot skal tilføjes nye værdityper. Visualisering af spillet foregår ved at definere et billede for hvert spilelement, og få programmet til at tegne objektet på arrayets plads.

I sidste ende valgte vi denne metode fra på grund af den ulempe, at den skal sende et todimensionelt array med banens størrelse, hver gang banen skal tegnes. Ved en bane på f.eks. 100x100 betyder dette, at at sendes i alt 10000 elementer til View-koden, hver gang banen skal tegnes. Vores anvendte metode sender derimod kun de relevante elementer, dvs. æblets og slangens position, til View-koden.

\subsubsection{Snake}
Da slangen i snake-spillet består af en række felter, som alle har netop en koordinat i forbindelse med andre led, er en effektiv måde at bestemme slangens position på en ArrayList, idet denne datastrukturer er fleksibel i størrelse og passer til formålet. Når slangen vokser i størrelse, bliver dette dog mindre effektivt, idet slangens hoved altid sættes som element 0. Når slangen vokser, tilføjes et nyt element på plads 0, hvormed hele listen skal flyttes. En anden mulighed ville være at bruge en anden datastruktur, f.eks. LinkedList, eller lade hovedet være defineret som element positions.size()-1, hvormed nye hovedet tilføjes sidst i listen. Et problem ved at bruge LinkedList er dog, at denne datastruktur ikke tillader vilkårlig adgang af værdier, men derimod altid bevæger sig fra første eller sidste element. Dette problem kan løses ved at bruge en iterator, men blev fravalgt, idet det skabte problemer, når listen skulle bruges på tværs af klasserne.

\subsubsection{Score}
Til implementationen af scoren blev to løsninger foreslået. Enten at lade scoren være et datafelt i game-klassen, eller at lade det være en klasse for sig selv. Ved at lade scoren være et datafelt, bliver implementationen simplere. At lade scoren være en klasse for sig selv har derimod fordelen, at der kan tilføjes en observer til Score-klassen, som dermed kun opdateres, når scoren ændrer sig. Scorepanelet tegnes ikke i samme klasse som banen, og kan derfor holdes seperat, så scorepanelet kun gentegnes, når scoren ændrer sig. Hvis scoren derimod er et datafelt, tegnes scoren efter hver tur, også selvom scoren er uændret. Det blev bestemt at holde scoren som klasse for sig selv, så den kun blev tegnet om, når der skete ændringer. 

\subsubsection{Tegning af spillet}
For at visualisere spillet er det nødvendigt at kunne optegne banen, slangen og æblet. Dette gøres i klassen BoardPanel, som har metoderne drawLevel, drawSnake og drawFood, som hver især tegner deres tilsvarende element. Metoden paintComponent kalder de førnævnte metoder, således at baggrunden tegnes først, så banen, så æblet og sidst slangen. Alting gentegnes hver gang spillet opdateres, hvormed der "tegnes over" det gamle billede. Det kan her argumenteres for, at f.eks. baggrunden ikke bør gentegnes, når slangen bevæger sig, lige som store dele af banen forebliver uændret, og derfor ikke behøver gentegnes. Alternativt kunne man lave et system, som undersøger hvilke områder der skal gentegnes, og hvilke der er uændret, og derfor ikke skal gentegnes. Dette kan dog i sidste ende betyde, at de kræfter der spares på tegning i stedet blot bruges på at afgøre, hvad der skal tegnes.

\subsubsection{Tegning af vinduet}
En alternativ metode til at gøre vinduet justerbart, er at give hvert felt en absolut størrelse. 
Så ser spillepladen altid pæn ud, og kommer ikke til at afhænge af alle mulige vinduesforhold. Ulempen er så bare, at alt efter hvor stor banen er, så kan vinduet blive for stort til computerskærmen, og hvis den er for lille, kan man ikke forstørre banen op. På denne måde er det en "for let" løsning bare at sætte absolute værdier ind, for ikke at få en "grim" bane.
Problemet bliver løst i avanceret snake ved at lave en baggrund og låse banens forhold, hvormed banen altid fylder mest muligt af vinduet ud, mens den beholder sin form, og den resterende plads bliver udfyldt af baggrunden. 

\subsubsection{Brug af \textit{Game}-klassen}
Efter vi havde delt de fleste funktioner ud i klasserne, besluttede vi os for at samle nogle metoder i \textit{Game}-klassen frem for deres oprindelige klasse, f.eks. \textit{GenereateFood}-metoden og hvordan banen skulle opstilles. Vi satte ikke \textit{move}-metoden ind i \textit{Game}-klassen frem for \textit{Snake}-klassen, da den ikke som sådan skal bruge nogle informationer fra andre klasser. Den skal bare bevæge sig.
Grunden til vi valgte, at lægge andre klassers metoder ind i \textit{Game}, er både fordi, det er smart at have det meste samlet et sted, og ikke behøve at hente alt for mange get-metoder fra de andre klasser. 
I den avancerede del af snake, ender vi med at gøre det modsatte. Vi simplificerer vores \textit{Game} klasse fuldstændigt, og gør den i stedet til en super-klasse med abstrakte metoder. Derfra nedarver to andre klasser fra den, og på den måde er metoderne bare uddeligeret til de to klasser. Man kan også sige, at \textit{Game} stadig består af mange funktioner, siden det er en superklasse til to store under-klasser. 