\section{Design}
Snake-spillet er lavet efter et \textit{Model-View-Controller}-design (MVC), hvorved selve spillet, styringen af spillet og den visuelle repræsentation af spillet holdes adskilt i tre dele. På denne måde interagerer brugeren kun med den del af programmet, der er dedikeret til styring. Styringen manipulerer programmets tilstand i \textit{model}-koden, som visualiseres i \textit{view}-koden. Dette betyder derfor også, at alle funktioner, der påvirker programmets tilstand, skal holdes i \textit{model}-koden. \textit{Control} modtager kun input fra brugeren, og sender dette videre til \textit{View} og \textit{Model}. Det er muligt gennem en observer at "observere" ændringerne i \textit{modelen}, som bruges til at opdaterer \textit{View}.

Simpel Snake er designet, så spillets funktioner ligger i klassen \textit{Game} i model-pakken. \textit{Game} får da spillets objekter fra andre klasser i \textit{model}-pakken, f.eks. Level (banen) og Snake (slangen). Spillets tilstand ændres, når der modtages input fra control-klasserne, som bestemmer hvornår og hvordan slangen bevæger sig. \textit{Control}-klassen opretter en keylistener, der gennem piletasterne, styrer slangen gennem banen, og derved gennem torussen. Vi har også valgt at lave to enum-klasser, \textit{Direction}-klassen og \textit{Action}-klassen, til at holde styr på nogle forhold gennem spillet. Det er nemmere at tilkoble en masse kommandoer og statements til hver retning og action-state frem for en integer, da man nok kommer til at kalde enum-klasserne i flere forskellige klasser, og tilkoble virkelig mange kommandoer, der skal bruges i hvert state. Så for ordnens skyld, så er det mere overskueligt med enum-klasser.

I \textit{BoardPanel}-klassen er en observer, som notificeres hver gang banens tilstand ændres. Når dette sker, eller når spillet startes, tegnes banen vha. klasserne \textit{View} og \textit{BoardPanel}. Disse klasser modtager information fra model-klasserne, f.eks. \textit{Snake}, til at bestemme hvordan spillet tegnes. \textit{BoardPanel} gentegner hele spillet hver gang spillet opdateres. Først tegnes selve banen, derefter slangen og til sidst æblet. 
Scoren holdes opdateret i en \textit{Score}-klasse i \textit{model}-pakken, der observeres af \textit{ScorePanel}. \textit{ScorePanel} ligger som et panel øverst over selve spilletpladen, og har kun til formål at holde styr på scoren.

For at starte spillet bruges klassen \textit{Driver}, som opretter et nyt \textit{Game}-, \textit{View} og \textit{Control}-objekt.

VISIODIAGRAM!!

\subsection*{Immutable klasser - Food, Field og Board}
Klasserne Food, Field og Board er meget små. De har alle samme kun to værdier i sig (enten en coloum og row eller en dimension). Vi har derfor designet klasserne sådan at de ikke kan ændres efter at de er blevet oprettet. Dette sikre os at vi kan returnere vores game board i en getter og være 100\% sikre på at undefra kommende klasse ikke ændre det. Java har ikke et constant begreb. Hvis du har en reference til et object og objected exposer sine interne variable,  kan man ændre på klassen. Nogengange kan det godt være svært at resonere omkring koden, hvis alle objecter vilkårligt kan ændre hinanden. Immutable klasser sikre at man ikke kan ændre deres start værdier. En lille ulemper ved immutable klasser er at det kan kræve lidt mere computer kræft at skulle oprette nye objecter hele tiden, i stedet for at bare skulle assigne til object variablerne.
